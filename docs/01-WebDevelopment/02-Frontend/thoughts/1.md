---
sidebar_position: 1
title: 又让我掏到了OOP和FP
---

```javascript

<app-layout [selected]="'Expedientes'" #appLayout>

 <div class="form-field" *ngIf="appLayout.isEntity()" >
                           //content
                        </div>

</app-layout>
```

- how to reuse the component?
- use the input, [selected], to change the component's content to render. Parent-> children 
- the parent component wanna use the children's attricute, #appLayout mark the component, and '*ngIf="appLayout.isEntity()"' to get the entity of the component.




## React 中的实现方式：

在 React 中，实现相同功能需要使用 **ref** 和 **forwardRef**：

### 1. 子组件 (Layout.js)
```jsx
import React, { forwardRef, useImperativeHandle } from 'react';

const Layout = forwardRef(({ selected }, ref) => {
  const [user, setUser] = useState(null);
  
  // 暴露方法给父组件
  useImperativeHandle(ref, () => ({
    isEntity: () => user && 'cif' in user,
    getUserName: () => user ? user.name : ''
  }));

  return (
    <div>
      <h1>{selected}</h1>
      {/* 其他内容 */}
    </div>
  );
});
```

### 2. 父组件
```jsx
import React, { useRef } from 'react';
import Layout from './Layout';

const ParentComponent = () => {
  const layoutRef = useRef();
  
  return (
    <Layout selected="Expedientes" ref={layoutRef}>
      {layoutRef.current?.isEntity() && (
        <div className="form-field">
          {/* 内容 */}
        </div>
      )}
    </Layout>
  );
};
```


## 关键区别：

| 特性 | Angular | React |
|------|---------|-------|
| 子组件引用 | `#templateVar` | `useRef()` + `forwardRef()` |
| 暴露方法 | 自动暴露公共方法 | 需使用 `useImperativeHandle` |
| 条件渲染 | `*ngIf` | `&&` 或三元运算符 |

我观察到的，react使用的是hook来的，但是angular是使用面向对象 + 依赖注入



## 底层逻辑区别

### React：函数式 + 不可变数据流
- **核心机制**：Hook + Ref 系统
- **哲学**：数据向下流动，事件向上流动
- **实现方式**：
  ```jsx
  // 需要显式转发ref
  const Child = forwardRef((props, ref) => {
    useImperativeHandle(ref, () => ({
      childMethod: () => {...}
    }));
  });

  // 需要显式创建ref
  const parent = () => {
    const childRef = useRef();
    return <Child ref={childRef} />;
  }
  ```

### Angular：面向对象 + 依赖注入
- **核心机制**：模板引用变量 + 组件实例
- **哲学**：组件即类实例，天然拥有公共API
- **实现方式**：
  ```html
  <!-- 自动暴露所有公共方法和属性 -->
  <app-child #childRef></app-child>
  {{ childRef.publicMethod() }}
  ```

## 根本差异

| 方面 | React | Angular |
|------|-------|---------|
| **组件本质** | 函数闭包 | 类实例 |
| **API暴露** | 需要显式选择 | 自动公开所有公共成员 |
| **模板能力** | JSX（JavaScript扩展） | 强大的模板语法 |
| **思维模型** | 函数组合 | 面向对象 |

## 设计哲学差异

**React** 强调显式和谨慎的API设计，要求开发者明确指定要暴露的内容。

**Angular** 采用更传统的面向对象方式，组件类的公共成员自然成为模板API。

两者都是有效的设计选择，只是基于不同的编程范式和哲学理念。


这是一个很好的问题 👍
你提到的 **React 和 Angular API 设计差别**，确实可以用类比来理解。

---

### 1. 类比：餐厅点餐 🍽️

* **Angular** 像一家传统餐厅：

  * 菜单（组件类）上列出来的所有菜（公共成员）都可以直接点。
  * 你作为顾客（模板）能点到菜单上所有公开的菜，不需要餐厅老板（开发者）额外声明哪些能点、哪些不能点。
  * 好处：自然直观，所有公共东西都能用。
  * 坏处：如果菜单上东西太多，顾客可能不知道哪些是真正推荐的。

* **React** 像一家现代简餐店：

  * 店家明确告诉你「今日可点的 3 种套餐」（props）。
  * 其他东西（比如厨房怎么炒、有什么原料）你完全看不到，也不能随便点。
  * 好处：API 非常清晰，用户知道能点啥、不能点啥。
  * 坏处：需要开发者**显式设计**套餐（props），写起来要更谨慎。

---

### 2. 为什么一个是“对象”，一个是“函数”？

* **Angular** 是基于 **面向对象 (OOP)** 的设计：

  * 组件就是一个类 (class)。
  * 类的 **public 属性/方法** 天然就是模板可访问的 API。
  * 这种设计很符合 Java / C# 背景的工程师思路。

* **React** 是基于 **函数式编程 (FP)** 的设计：

  * 组件就是一个函数。
  * 这个函数接收参数（props），返回 UI（JSX）。
  * 因为函数没有“public 属性”一说，所以你必须 **显式声明要暴露的 props**，其余内部逻辑都是黑箱。

---

### 3. 再换个比喻（工具箱 🧰）

* **Angular**：像一个工具箱（class）。

  * 里面的公共工具（public 成员）你都能拿出来用。
* **React**：像一个函数参数列表。

  * 你只能用它明确传给你的工具（props），其余工具藏在箱子里你看不到。

---

👉 总结一句：

* **Angular** 倾向于「我有什么就给你用」（面向对象，公共成员 = API）。
* **React** 倾向于「我只告诉你能用什么」（函数式，props = API）。

---


2. 为什么一个是“对象”，一个是“函数”？

Angular 是基于 面向对象 (OOP) 的设计：

组件就是一个类 (class)。

类的 public 属性/方法 天然就是模板可访问的 API。

这种设计很符合 Java / C# 背景的工程师思路。

React 是基于 函数式编程 (FP) 的设计：

组件就是一个函数。

这个函数接收参数（props），返回 UI（JSX）。

因为函数没有“public 属性”一说，所以你必须 显式声明要暴露的 props，其余内部逻辑都是黑箱。



## 我自己觉得
一个是OOP，OOP是你去找这个对象的属性，然后这个像是一个箱子，你去拿取这个箱子的组件，然后你使用的时候，箱子的表面会有选项【color】，比如决定这个箱子的颜色,箱子内部的东西你也可以用，就是箱子内部的引用之后，然后你再使用这个箱子里的东西。这个箱子类比class。


一个是函数类,函数在我看来像是一个小型的机器人，比较抽象更有逻辑感，你首先要给这个机器人写好指令，就是用函数和这个机器人对话，比如useref，对话的方法和工具叫做hook，然后你使用这个机器人，也要发指令，就是那个viewChild. 这个机器人类比就是函数类。你和他的交互更有逻辑感。👉 机器人默认是个黑箱，你只能通过指令（props）告诉它要干什么，它只会显式暴露允许交互的能力。其实也是个箱子，但是更抽象。React 像 API 服务机器人：你必须写好请求（props），它才会返回响应（UI），其他的它不会让你碰。

## 一些历史

哦～你问的这个问题已经到 **前端框架历史 + 编程思想演进** 的层面了，非常深刻 👏。我帮你拆解一下：

---

## 🔹 为什么先有 Angular (OOP 风格) 再有 React (函数式风格)？

### 1. **历史背景：面向对象是主流**

* 在 **2000\~2010 年代**，大多数开发者来自 **Java / C# 背景**，他们的思维方式是 OOP：类、对象、继承、接口。
* 企业软件、桌面程序、后端服务几乎全是 OOP。
* 所以前端框架在设计时，**顺应主流思维**，用 **class 组件、依赖注入、MVC 模式**，这就是 AngularJS（2010）和 Angular（2016 重构）的起点。

👉 对当时的开发者来说，写前端跟写 Java/C# 差不多，很容易上手。

---

### 2. **React 的出现：拥抱函数式思维**

* Facebook 内部在 2013 年发布 React，目标是解决 **复杂 UI 状态管理**的问题。
* React 背后的思想不是「再做一个 MVC」，而是借鉴了 **函数式编程 (FP)**：

  * UI = f(state) （界面是状态的函数）。
  * 每次状态变化时，组件函数重新运行，返回新的 UI。
* 这种模式极大地降低了「状态驱动 UI」的复杂度。

👉 React 本质上是一个 **函数式渲染引擎**，而不是传统的 OOP 框架。

---

### 3. **为什么从 OOP → FP？**

这是一个编程思想的自然演进：

* **OOP 优势**：

  * 抽象现实世界（对象 = 实体，属性+方法 = 特征+行为）。
  * 直观、符合人类思维。

* **OOP 弱点**：

  * 状态分散在对象里，不同对象之间的状态同步非常难。
  * UI 是高度依赖状态的系统，OOP 很快就陷入「状态地狱」。

* **函数式编程优势**：

  * 强调 **不可变数据**、**纯函数**。
  * 输入相同 → 输出相同，不依赖外部隐藏状态。
  * 很适合描述 UI：UI = f(state)。

所以 React 的函数式模型在 UI 场景下更简单、更稳定。

---

### 4. **类比：为什么人类要从 OOP → FP？**

* OOP 就像 **造房子**：你需要很多砖块（对象），它们各自有属性和功能，搭起来就是一栋楼。
* FP 就像 **写公式**：只要给定参数，公式就能算出结果。UI 复杂度爆炸时，公式往往比房子更好维护。

---

### 5. **趋势总结**

* **先有 Angular (OOP)**：因为当时大家都是 OOP 思维。
* **后来有 React (FP)**：因为 UI 状态越来越复杂，OOP 在 UI 领域暴露出弊端，需要 FP 的思想来简化。
* 现在很多框架（Vue 3、SolidJS、Svelte）都受 React 启发，往 FP 靠拢。

---

✅ **一句话总结**：
前端从 Angular（OOP）到 React（函数式）的演变，其实是 **软件工程整体从 OOP → FP 的小型缩影**。

* OOP 更贴近人类对「对象」的直觉。
* FP 更贴近计算机对「函数关系」的本质，尤其适合 UI 这种状态驱动场景。

---

## 为啥react后来居上了？

因为对前端的需求增多了 OOP 在 UI 领域暴露出弊端，需要 FP 的思想来简化。 人类的工具进化了

🔹 4. 直观类比
UI 不是静态的，而是随着 状态 (state) 变化不断更新的。

例子：一个电商页面

登录状态 → 显示「欢迎 xxx」

购物车状态 → 显示「3 件商品」

支付状态 → 显示「支付成功」

UI = 状态的映射。
只要状态一变，UI 就得同步变。

OOP 模式：
就像你要维持一个「乐高积木城堡」，每次有变化你要手动把某些砖块拿掉、换掉、补上。操作繁琐，容易漏。

FP 模式：
就像你有一个「3D 打印机」，只要告诉它新的设计图（state），它就自动打印出新的城堡（UI）。你不用关心怎么一块一块替换。






